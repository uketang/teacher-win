/*******************************************************************************
 * javascript glue wrapper of uimsdk module
 * @module uimsdk.js
 * @author zhoukai
*******************************************************************************/

var dns             = require('dns');
var net             = require('net');
var util            = require('util');
var EventEmitter    = require('events').EventEmitter;
var uimsdk          = null;

if (process.uimsdkBuildType == 'debug') {
    uimsdk = require('./Debug/'+process.platform+'/uim.node');
} else {
    uimsdk = require('./Release/'+process.platform+'/uim.node');
}



uimsdk.ALIGN = function(size, boundary){
    return (((size) + ((boundary) - 1)) & ~((boundary) - 1));
}

if (!EventEmitter.listenerCount) {
    EventEmitter.listenerCount = function(emitter, type) {
      var ret;
      if (!emitter._events || !emitter._events[type])
        ret = 0;
      else if (typeof emitter._events[type] === 'function')
        ret = 1;
      else
        ret = emitter._events[type].length;
      return ret;
    };
}

function parseHost(url, callback){
    if (typeof callback != 'function') {
        throw Error('Invalid arguments.');
    };
    var result = {}, offset = 0;
    if (url.substr(0, 7) == "http://") {
        result.protocol = "http";
        result.port = 80;
        offset = 7;
    } else if (url.substr(0, 7) == "rtmp://") {
        result.protocol = "rtmp";
        result.port = 1935;
        offset = 7;
    } else if (url.substr(0, 7) == "rtsp://") {
        result.protocol = "rtsp";
        result.port = 554;
        offset = 7;
    } else if (url.substr(0, 8) == "https://") {
        result.protocol = "https";
        result.port = 443;
        offset = 8;
    } else if (url.substr(0, 8) == "rtmpe://") {
        result.protocol = "rtmpe";
        result.port = 1935;
        offset = 8;
    } else if (url.substr(0, 8) == "rtmps://") {
        result.protocol = "rtmps";
        result.port = 443;
        offset = 8;
    } else if (url.substr(0, 8) == "rtmpt://") {
        result.protocol = "rtmpt";
        result.port = 80;
        offset = 8;
    } else if (url.substr(0, 8) == "rtmfp://") {
        result.protocol = "rtmfp";
        result.port = 1935;
        offset = 8;
    } else {
        return callback(new Error('Unknown protocol.'));
    }
    url = url.substr(offset);
    var sep = url.search('/');
    if (sep > 0) {
        result.host = url.substr(0, sep);
        result.location = url.substr(sep);
        if (result.protocol === 'rtsp') {
            var at = result.host.search('@');
            if (at > 0) {
                result.host = result.host.substr(at + 1);
                var loginInfo = url.substring(0, at);
                loginInfo = loginInfo.split(':');
                if (loginInfo.length === 2) {
                    result.username = loginInfo[0];
                    result.password = loginInfo[1];
                };
            };
        };
        var ipport = result.host.split(':');
        var host = ipport[0];
        if (ipport.length > 1) {
            result.port = Number(ipport[1]);
        };
        if (net.isIPv4(host)) {
            result.ip = host;
            return callback(null, result);
        } else if ('localhost' === host) {
            result.ip = '127.0.0.1';
            return callback(null, result);
        } else {
            try{
                dns.resolve4(host, function(err, addresses){
                    if (err) {
                        return callback(err);
                    };
                    result.ip = addresses[0];
                    return callback(null, result);
                });
            }catch(e){
                return callback(e);
            }
        }
    } else {
        return callback(new Error('Invalid url['+url+'].'));
    }
}

function call_cb(callback, cmd){
    if (cmd) {
        var args = [cmd];
        args = args.concat(cmd.args);
        callback.apply(this, args);
    } else {
        callback();
    }
}

//******************************************************************************
// Constant variables definition
//
// User Control Message (4)
// The client or the server sends this message to notify the peer about
// the user control events. This message carries Event type and Event
// data.
//******************************************************************************

const CONST = {
    // Event data : stream id - send from server
    MUCTRL_STREAM_BEGIN         : 0,
    // Event data : stream id - send from server
    MUCTRL_STREAM_EOF           : 1,
    // Event data : stream id - send from server
    MUCTRL_STREAM_DRY           : 2,
    // Event data : stream id;ext event data : buffer length - send from client
    MUCTRL_SET_BUFFER_LENGTH    : 3,
    // Event data : stream id - send from server
    MUCTRL_STREAM_IS_RECORDED   : 4,
    // Event data : server timestamp - send from server(need client response)
    MUCTRL_PING_REQUEST         : 6,
    // Event data : client timestamp - send from client(response server request)
    MUCTRL_PING_RESPONSE        : 7,

    NOTIFY_AUDIO_SENTDONE       : 0x01,
    NOTIFY_VIDEO_SENTDONE       : 0x02,
    NOTIFY_META_SENTDONE        : 0x04,
    NOTIFY_CMD_SENTDONE         : 0x08,
    NOTIFY_ALL_SENTDONE         : 0x0F,
    NOTIFY_RAWDATA_RECVDONE     : 0x10,
    NOTIFY_RAWDATA_SENTDONE     : 0x20,
    NOTIFY_ACTIVECHECK          : 0x40,
    // Log binary io data to file control flags
    NOTIFY_LOGRECVBIN           : 0x80,
    // RTSP SDP data recv done notify
    NOTIFY_SDP_RECVDONE         : 0x0100,
    // RTSP packet data recv done notify
    NOTIFY_PACKET_RECVDONE      : 0x0200,

    // Active check event : ping packet has been sent to client successfully
    ACTIVECHECK_SENTPING        : 0,
    // Active check event : received ping packet from client
    ACTIVECHECK_RECVPING        : 1,
    // Active check event : pong packet has been sent to client successfully
    ACTIVECHECK_SENTPONG        : 2,
    // Active check event : received pong packet from client
    ACTIVECHECK_RECVPONG        : 3,

    BUFFER_EVENT_FULL           : 0,
    BUFFER_EVENT_EMPTY          : 1,

    NSFLAG_BUBBLE               : 0x01,
    NSFLAG_MEDIADATA            : 0x02,
    NSFLAG_AUDIOSAMPLEACCESS    : 0x04,
    NSFLAG_VIDEOSAMPLEACCESS    : 0x08,
    NSFLAG_BUFFEREVENT          : 0x10,

    PACKET_TYPE_USERCTRL        : 0x04,
    PACKET_TYPE_AUDIO           : 0x08,
    PACKET_TYPE_VIDEO           : 0x09,
    PACKET_TYPE_METADATA        : 0x12,
    PACKET_TYPE_COMMAND         : 0x14,

    FILTER_FLAG_DISABLEAUDIO    : 0x01,
    FILTER_FLAG_DISABLEVIDEO    : 0x02,
    FILTER_FLAG_LOGTIMESTAMP    : 0x04,

    AVINFO_FLAG_HASAUDIO        : 0x01,
    AVINFO_FLAG_HASVIDEO        : 0x02,

    AV_SAMPLE_FLTP              : 0x01,
    AV_SAMPLE_S16P              : 0x02,

    AV_ENABLE_NS                : 0x01,
    AV_ENABLE_AGC               : 0x02,
    AV_ENABLE_VAD               : 0x04,

    MUXFLAG_VIDEO               : 0x01,
    MUXFLAG_AUDIO               : 0x02,
    MUXFLAG_OVERLAY             : 0x04,

    SCKERNEL_FF                 : 0x01,
    SCKERNEL_DX                 : 0x02,
    SCKERNEL_DF                 : 0x03,

    PROTOCOL_RTMP               : 0x01,
    PROTOCOL_QUIC               : 0x02,
};
function copyProperties(target, source) {
    for (var k in source)
        target[k] = source[k];
}
copyProperties(uimsdk, CONST);

/*******************************************************************************
* A uimsdk.RTMPCall object is a remote call information collection, contains RPC 
* command name, transaction id, properties, arguments as well as response 
* context.
*
* @class uimsdk.RTMPCall
*******************************************************************************/

/**
 * 为当前调用返回一个_result结果.
 * 该接口必须是远端发过来的调用对象，且被调函数名不能为'onStatus'，
 * 即不能调用'onStatus'调用对象的这一接口。
 *
 * @method echoResult
 * @public
 * @param ... {Number/String/Boolean/Array/Object/Buffer} 返回的参数
 * @example
 *     cmd.echoResult(arg1, ..., argN);
 **/
uimsdk.RTMPCall.prototype.echoResult = function(__args){
    var args = ['_result'];
    for (var i = 0; i < arguments.length; i++) {
        args.push(arguments[i]);
    };
    this.echo.apply(this, args);
}

/**
 * 为当前调用返回一个_error结果.
 * 该接口必须是远端发过来的调用对象，且被调函数名不能为'onStatus'，
 * 即不能调用'onStatus'调用对象的这一接口。
 *
 * @method echoError
 * @public
 * @param ... {Number/String/Boolean/Array/Object/Buffer} 返回的参数
 * @example
 *     cmd.echoResult(arg1, ..., argN);
 **/
uimsdk.RTMPCall.prototype.echoError = function(__args){
    var args = ['_error'];
    for (var i = 0; i < arguments.length; i++) {
        args.push(arguments[i]);
    };
    this.echo.apply(this, args);
}

/*******************************************************************************
 * Javascript version of NetStream in actionscript3. Only client-side supported.
 * 
 * @class uimsdk.NetStream
*******************************************************************************/

uimsdk.NetStream = function(conn, streamId){
    this.connection = conn;
    this.streamId = streamId;
    this.closed = false;
    conn.streams[streamId] = this;
    this.delay = 0;
    this.dataListeners = [];
};

/**
 * 为特定事件添加一个监听处理程序.
 * 当前支持除'_error/_result/onStatus/connect/error/close'等事件之
 * 外的任何自定义事件.上述事件为内部保留事件，用户不应定义与这些事
 * 件同名的事件处理函数。与用户自定义事件相对应的事件处理函数的参
 * 数列表与远端调用时传入的参数列表一致。
 *
 * @method on
 * @public
 * @async
 * @param event_name {String} 要订阅的事件名称
 * @param callback {function} 事件处理函数
 *
 * @example
 *     stream.on(event_name, function(){});
 **/

/**
 * 流关闭事件及其事件监听处理程序.
 * 该关闭事件仅表明当前流被关闭，并不意味着RTMP连接被关闭。
 *
 * @event close
 * @example
 *     stream.on('close', function(){
 *         // Do some recycle work
 *     });
 **/

/**
 * 对端发过来的流关闭事件及其事件监听处理程序.
 * 该关闭事件由对端发出，用以关闭当前流。
 *
 * @event closeStream
 * @example
 *     stream.on('closeStream', function(cmd){
 *         stream.close();
 *     });
 **/

/**
 * 错误事件及其事件监听处理程序.
 * 如果添加'error'事件监听函数，则当出现内部错误时回调函数将被调用。
 * 
 * @event error
 * @param error_msg {Error} 错误信息
 * @example
 *     stream.on('error', function(err){
 *         console.dir(err);
 *     });
 **/

/**
 * RTMP网络流状态事件及其事件监听处理程序.
 * 如果添加'onStatus'事件监听函数，则当出现网络状态事件时回调函数将
 * 被调用。'onStatus'事件发送自网络对端，是一种不需要回复的远程调用，
 * 用于通知网络对端特定的状态信息，包括流的播放、发布状态等。
 *
 * @event onStatus
 * @param event {Object} 状态信息
 * @example
 *     stream.on('onStatus', function(event){
 *         console.dir(event);
 *     });
 **/

/**
 * Audio/Video数据及其数据监听处理程序.
 * 如果添加'data'事件监听函数，则当出现Audio/Video数据包时回调函数将
 * 被调用。
 *
 * @event data
 * @param data {Object} Audio/Video数据
 * @example
 *     stream.on('data', function(data){
 *         console.dir(data);
 *     });
 **/

/**
 * metadata数据及其数据监听处理程序.
 * 如果添加'onMetaData'事件监听函数，则当出现metadata数据包时回调函
 * 数将被调用。
 *
 * @event onMetaData
 * @param data {Object} metadata数据
 * @example
 *     stream.on('onMetaData', function(data){
 *         console.dir(data);
 *     });
 **/

/**
 * 调用一个远端处理函数.
 * 如果指定返回结果的回调处理函数，则远端理论上应该返回结果，该结果
 * 由该回调函数处理，否则，不返回结果。回调函数的第一个参数为远端返
 * 回的调用对象（uimsdk.RTMPCall实例）。理论上，返回结果也是一个远程调
 * 用，只不过是针对特定函数_result和_error函数的特定调用。返回
 * _result表示远端函数正确执行；返回_error则表示远端函数执行出错。
 *
 * @method call
 * @public
 * @async
 * @param proc_name {String} 要调用的远端函数的名称
 * @param property {Number/String/Boolean/Array/Object/Buffer} 要传递给远端函数的属性参数
 * @param ... {Number/String/Boolean/Array/Object/Buffer} 要传递给远端函数的参数
 * @param callback {function} [可选], 远端函数返回结果的处理函数
 * @example
 *     stream.call('foo', props, 'arg1', 'arg2', function(cmd){
 *         console.dir(cmd);
 *     });
 **/
uimsdk.NetStream.prototype.call = function(){
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
        if (i + 1 < arguments.length && typeof arguments[i] == 'function') {
            throw Error('Invalid arguments');
        };
        args.push(arguments[i]);
    };
    var name = args[0] || null;
    if (!name) {
        throw Error('Invalid arguments');
    };
    var cmd = {};
    cmd.name = args.shift();
    if (args.length > 0 && typeof args[args.length - 1] == 'function') {
        cmd.callback = call_cb.bind(this, args.pop());
    }
    if (!args.length) { // command property must be assigned
        throw Error('Invalid arguments, property object MUST BE assigned.');
    };
    cmd.props = args.shift();
    cmd.args = args;
    cmd.channelId = 3;
    cmd.streamId = this.streamId;
    new Error(cmd);
    if (cmd.name === 'onStatus') {
        this.connection.__call__(cmd, 0);
    } else{
        this.connection.__call__(cmd);
    };
}

/**
 * 发送一个数据包到订阅者发送队列，该数据包必须是metadata/video/audio三种数据
 * 类型中的一种.
 *
 * @method feed
 * @public
 * @param packet {Object} 要发送的数据包对象
 * @example
 *     stream.feed({
 *         type : 0x12, // metadata
 *         size : 129,  // not used when type == metadata
 *         timestamp : 0,
 *         streamId : 0, // not used
 *         data : buffer_data, // not used when type == metadata
 *         metadata : {
 *             width: 320,
 *             height: 240,
 *             videodatarate: 0,
 *             framerate: 15,
 *             videocodecid: 2,
 *             audiosamplerate: 22050,
 *             audiosamplesize: 16,
 *             stereo: true,
 *             audiocodecid: 2
 *         }
 *     });
 *     stream.feed({
 *         type : 0x08, // audio data
 *         size : 131,  // size of buffer_data
 *         timestamp : 40, // milliseconds
 *         streamId : 0, // not used
 *         data : [buffer_data], // array of audio data buffer which total size is 131
 *     });
 **/
uimsdk.NetStream.prototype.feed = function(packet, callback){
    if (typeof packet != 'object' || !packet.type || !packet.hasOwnProperty('timestamp')) {
        throw Error('Invalid arguments.');
    }
    switch(packet.type){
    case uimsdk.PACKET_TYPE_METADATA:
        if (!packet.hasOwnProperty('metadata') || typeof packet.metadata != 'object') {
            throw Error('Invalid metadata packet.');
        }
        packet.streamId = this.streamId;
        break;
    case uimsdk.PACKET_TYPE_AUDIO:
    case uimsdk.PACKET_TYPE_VIDEO:
        if (!packet.hasOwnProperty('data') || !(packet.data instanceof Array)) {
            throw Error('Invalid audio/video packet[must has `data`].');
        } else {
            var size = 0;
            for (var i in packet.data) {
                if (!(packet.data[i] instanceof Buffer)) {
                    throw Error('Invalid packet data element');
                } else {
                    size += packet.data[i].length;
                }
            };
            if (packet.size !== size) {
                throw Error('Invalid packet data size');
            }
            packet.streamId = this.streamId;
        }
        break;
    default:
        throw Error('Invalid packet type :' + packet.type);
        break;
    }
    if (typeof callback == 'function') {
        return this.connection.__feed__(packet, callback);
    } else{
        return this.connection.__feed__(packet, function(err){
            if (err) {
                throw err;
            };
        });
    };
}

/**
 * 发送一个数据包到订阅者发送队列，该数据包必须是metadata/video/audio三种数据
 * 类型中的一种.
 *
 * @method feedRaw
 * @public
 * @param packet {uimsdk.Packet} 要发送的数据包对象,该对象必须是ums.Packet对象
 * @example
 *     stream.feedRaw(packet);
 **/
uimsdk.NetStream.prototype.feedRaw = function(packet, callback){
    if (!(packet instanceof uimsdk.Packet)) {
        throw Error('Invalid arguments.');
    }
    switch(packet.type){
    case uimsdk.PACKET_TYPE_METADATA:
        if (!packet.hasOwnProperty('metadata') || typeof packet.metadata != 'object') {
            throw Error('Invalid metadata packet.');
        }
        packet.streamId = this.streamId;
        break;
    case uimsdk.PACKET_TYPE_AUDIO:
    case uimsdk.PACKET_TYPE_VIDEO:
        if (packet.size !== packet.length) {
            throw Error('Invalid packet size');
        }
        packet.streamId = this.streamId;
        break;
    default:
        throw Error('Invalid packet type :' + packet.type);
        break;
    }
    if (typeof callback == 'function') {
        return this.connection.__feedRaw__(packet, callback);
    } else{
        return this.connection.__feedRaw__(packet, function(err){
            if (err) {
                throw err;
            };
        });
    };
}

/**
 * 发送一个流控制指令.
 *
 * @method sendUserCtrl
 * @public
 * @param packet {Object} 要发送的数据包对象
 * @example
 *     stream.sendUserCtrl(uimsdk.PACKET_TYPE_USERCTRL);
 **/
uimsdk.NetStream.prototype.sendUserCtrl = function(ctrl, callback){
    if (typeof ctrl != 'number') {
        throw Error('Invalid arguments.');
    }
    switch(ctrl){
    // Event data : stream id - send from server
    case uimsdk.MUCTRL_STREAM_BEGIN:
    // Event data : stream id - send from server
    case uimsdk.MUCTRL_STREAM_EOF:
    // Event data : stream id - send from server
    case uimsdk.MUCTRL_STREAM_DRY:
    // Event data : stream id - send from server
    case uimsdk.MUCTRL_STREAM_IS_RECORDED:
    // Event data : server timestamp - send from server(need client response)
    case uimsdk.MUCTRL_PING_REQUEST:
        var packet = {
            type : uimsdk.PACKET_TYPE_USERCTRL,
            data : ctrl,
            streamId : this.streamId
        }
        if (typeof callback == 'function') {
            return this.connection.__feed__(packet, callback);
        } else{
            return this.connection.__feed__(packet, function(err){
                if (err) {
                    throw err;
                };
            });
        };
        break;
    default:
        throw Error('Invalid user control type :' + ctrl);
        break;
    }
}

/**
 * 向服务端发送一个播放命令.
 * 调用该接口并不会返回_result或_error结果，要想捕获播放事件，请调用
 * uimsdk.NetStream.on接口订阅onStatus事件，并判断event.code值是否为下述状态之一：
 *      <br>&nbsp;&nbsp;&nbsp;&nbsp;1.'NetStream.Play.StreamNotFound':表示流不存在；
 *      <br>&nbsp;&nbsp;&nbsp;&nbsp;2.'NetStream.Play.Reset':表示播放重置；
 *      <br>&nbsp;&nbsp;&nbsp;&nbsp;3.'NetStream.Play.Start':表示播放开始；
 *      <br>&nbsp;&nbsp;&nbsp;&nbsp;4.'NetStream.Play.Stop':表示播放停止；
 *      <br>&nbsp;&nbsp;&nbsp;&nbsp;5.'NetStream.Play.Complete':表示播放结束；
 *      <br>&nbsp;&nbsp;&nbsp;&nbsp;6.'NetStream.Play.Transition':转换指令；
 *      <br>&nbsp;&nbsp;&nbsp;&nbsp;7.'NetStream.Play.TransitionComplete':转换结束（通过onPlayStatus发送）；
 *      <br>&nbsp;&nbsp;&nbsp;&nbsp;8.'NetStream.Play.UnpublishNotify':发布者停止发布通知。
 *      <br>&nbsp;&nbsp;&nbsp;&nbsp;9.'NetStream.Play.Failed':未知的失败；
 *      <br>&nbsp;&nbsp;&nbsp;&nbsp;10.'NetStream.Play.FileStructureInvalid':文件结构不可用；
 *      <br>&nbsp;&nbsp;&nbsp;&nbsp;11.'NetStream.Play.NoSupportedTrackFound':不支持的流格式；
 *      <br>&nbsp;&nbsp;&nbsp;&nbsp;12.'NetStream.Play.InsufficientBW':带宽不够。
 * <br>形如：
 *
 *      stream.on('onStatus', function(cmd, event){
 *          switch(event.code) {
 *              case "NetStream.Play.Failed":
 *                  // "error",An error has occurred in playback for a reason other than those 
 *                  // listed elsewhere in this table, such as the subscriber not having read
 *                  // access.
 *                  break;
 *              case "NetStream.Play.FileStructureInvalid":
 *                  // "error",(AIR and Flash Player 9.0.115.0) The application detects an
 *                  // invalid file structure and will not try to play this type of file.
 *                  break;
 *              case "NetStream.Play.NoSupportedTrackFound":
 *                  // "error",(AIR and Flash Player 9.0.115.0) The application does not
 *                  // detect any supported tracks (video, audio or data) and will not try to
 *                  // play the file.
 *                  break;
 *              case "NetStream.Play.StreamNotFound":
 *                  // "error",The file passed to the NetStream.play() method can't be found.
 *                  break;
 *              case "NetStream.Play.InsufficientBW":
 *                  // "warning",(Flash Media Server) The client does not have sufficient
 *                  // bandwidth to play the data at normal speed.
 *                  break;
 *              case "NetStream.Play.PublishNotify":
 *                  // "status",The initial publish to a stream is sent to all subscribers.
 *                  break;
 *              case "NetStream.Play.Reset":
 *                  // "status",Caused by a play list reset.
 *                  break;
 *              case "NetStream.Play.Start":
 *                  // "status",Playback has started.
 *                  break;
 *              case "NetStream.Play.Stop":
 *                  // "status",Playback has stopped.
 *                  break;
 *              case "NetStream.Play.Transition":
 *                  // "status",(Flash Media Server 3.5) The server
 *                  // received the command to transition to another stream as a result of bitrate stream switching.
 *                  // This code indicates a success status event for the NetStream.play2() call to initiate a stream
 *                  // switch. If the switch does not succeed, the server sends a NetStream.Play.Failed event instead.
 *                  // When the stream switch occurs, an onPlayStatus event with a code of
 *                  // "NetStream.Play.TransitionComplete" is dispatched. For Flash Player 10 and later.
 *                  break;
 *              case "NetStream.Play.UnpublishNotify":
 *                  // "status",An unpublish from a stream is sent to all subscribers.
 *                  break;
 *              case "NetStream.Play.Complete":
 *                  // "status",Playback has completed.
 *                  break;
 *          }
 *      });
 *
 * @method play
 * @public
 * @param streamName {String} 要播放的流的名称
 * @param startPos {Number} 开始播放的起始时间戳。如果startPos < -1 ,表示
 *        如果存在同名的直播流，则优先放直播流，如果直播流不存在
 *        而点播文件存在，则播放点播文件；如果startPos = -1，表
 *        示只播放同名的直播流；如果startPos >= 0则表示只播放点
 *        播流)
 **/
uimsdk.NetStream.prototype.play = function(props, streamName, startPos){
    if (arguments.length < 3 || !streamName || typeof startPos != 'number') {
        throw Error('Invalid arguments.');
    };
    var args = ['play', props, streamName.toString(), startPos];
    streamName = streamName.toString();
    for (var i = 2; i < arguments.length; i++) {
        args.push(arguments[i]);
    };
    this.call.apply(this, args);
    
}

/**
 * 将本地发布池中的音视频数据流发布到远端服务器.
 * 该接口是一个复合操作，接口内部完成两个操作：1.向远端服务器发送一个
 * 'publish'调用；2.将本地发布池中的音视频数据以直播流的形式发布到远端
 * 服务器。要想捕获播放事件，请调用NetStream.on接口订阅onStatus事件，形如：
 *     NetStream.on('onStatus', function(cmd, event){});
 * 并判断event.code值是否为下述状态之一：
 * 1.'NetStream.Publish.Start':表示流开始发布；
 * 2.'NetStream.Publish.BadName':表示流发布失败。
 *
 * @method publish
 * @public
 * @async
 * @param remoteStreamName {String} 要发布到远端服务器的流的名称
 * @param localStreamName {String} [可选]，作为数据源的本地的流的名称。如果
 *        不设置该参数，则该采用跟目标流相同的流名称.
 * @param callback {function} 异步操作结果回调函数，函数的第一个参数为
 *        操作结果错误信息，如果出错，则该值不为null
 *
 **/
uimsdk.NetStream.prototype.publish = function(props, streamName, mode) {
    if (arguments.length < 3 || !streamName || 
        (mode != 'live' && mode != 'record')) {
        throw Error('Invalid arguments.');
    };
    var args = ['publish', props, streamName.toString(), mode];
    streamName = streamName.toString();
    for (var i = 2; i < arguments.length; i++) {
        args.push(arguments[i]);
    };
    this.call.apply(this, args);
}

/**
 * 设置开启/关闭数据包冒泡功能.
 * 如果设置开启数据包冒泡功能，则可以通过监听'data'事件来接收到
 * Video/Audio/MetaData数据包。
 * 异步设置完成回调函数的第一个参数为出错信息，如果出错信息为null，
 * 则表明设置成功，否则，表明设置失败。
 *
 * 设置开启/关闭将Audio/Video数据转换成onMediaData包发送功能.
 * 如果设置开启数据包冒泡功能，则可以通过监听'onMediaData'事件来
 * 接收到Video/Audio数据包。
 * 异步设置完成回调函数的第一个参数为出错信息，如果出错信息为null，
 * 则表明设置成功，否则，表明设置失败。
 * 
 * @method setFlags
 * @public
 * @async
 * @param flags {Number} 是否开启数据包冒泡功能
 * @param callback {function} 异步设置完成回调函数
 * @example
 *     stream.setFlags(uimsdk.NSFLAG_BUBBLE | uimsdk.NSFLAG_MEDIADATA, function(err){
 *         if (err) {
 *             return console.dir(err);
 *         }
 *         stream.on('data', function(data){
 *             console.dir(data);
 *         });
 *         stream.on('bufferEvent', function(type, stats){
 *             console.dir(type);
 *         });
 *     });
 **/
uimsdk.NetStream.prototype.setFlags = function(flags, callback) {
    if (arguments.length < 2 || typeof flags != 'number' ||
        typeof callback != 'function') {
        throw Error('Invalid arguments.');
    };
    var self = this;
    self.connection.__setStreamFlags__(this.streamId, flags, function(){
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
            args.push(arguments[i]);
        };
        callback.apply(self, args);
    });
}

/**
 * 设置发送缓冲区长度.
 * 
 * @method setBufferLength
 * @public
 * @async
 * @param bufferLength {Number} 发送缓冲区长度，以毫秒为单位
 * @param callback {function} 异步设置完成回调函数
 * @example
 *     stream.setBufferLength(bufferLength, function(err){
 *         if (err) {
 *             return console.dir(err);
 *         }
 *     });
 **/
uimsdk.NetStream.prototype.setBufferLength = function(bufferLength, callback) {
    if (arguments.length < 2 || typeof bufferLength != 'number' ||
        typeof callback != 'function') {
        throw Error('Invalid arguments.');
    };
    var self = this;
    self.connection.__configSender__(this.streamId, 
        { bufferLength : bufferLength }, function(err){
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
            args.push(arguments[i]);
        };
        callback.apply(self, args);
    });
}

/**
 * 获取发送缓冲区长度。
 *
 * @property bufferLength
 * @type Number
 * @public
 * @example
 *     console.log(stream.bufferLength);
 **/
Object.defineProperty(uimsdk.NetStream.prototype, 'bufferLength', {
    get: function() {
        return this.connection.__getBufferLength__(this.streamId);
    },
    enumerable : true
});

/**
 * 设置发送缓冲区溢出通知长度.
 * 
 * @method setBufferOverflow
 * @public
 * @async
 * @param bufferOverflow {Number} 发送缓冲区长度，以毫秒为单位
 * @example
 *     stream.setBufferOverflow(100);
 **/
uimsdk.NetStream.prototype.setBufferOverflow = function(bufferOverflow, callback) {
    if (arguments.length < 2 || typeof bufferOverflow != 'number' ||
        typeof callback != 'function') {
        throw Error('Invalid arguments.');
    };
    var self = this;
    self.connection.__configSender__(this.streamId, 
        { bufferOverflow :  bufferOverflow }, function(err){
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
            args.push(arguments[i]);
        };
        callback.apply(self, args);
    });
    this.bufferOverflow = bufferOverflow;
}

/**
 * 主动关闭一个流。
 *
 * @method close
 * @public
 * @example
 *     stream.on('closeStream', function(cmd){
 *         stream.close(function(err){
 *             if (err) { return console.log(err); }
 *         });
 *     });
 **/
uimsdk.NetStream.prototype.close = function(callback) {
    var self = this;
    if (typeof callback != 'function') {
        callback = null;
    };
    if (self.closed) {
        if (callback) {
            return callback();
        };
        return;
    };
    self.connection.closeStream(this.streamId, function(err){
        if (callback) {
            callback(err);
        }
    });
}

/**
 * 获取事件监听器数量。
 *
 * @method listenerCount
 * @public
 * @param event_name {String} 事件名称
 * @example
 *     var count = stream.listenerCount('data');
 **/
uimsdk.NetStream.prototype.listenerCount = function(event_name) {
    return EventEmitter.listenerCount(this, event_name);
}


//*******************************************************************************
// Inherits
//*******************************************************************************

function inherits(target, source) {
  for (var k in source.prototype)
    target.prototype[k] = source.prototype[k];
}

inherits(uimsdk.NetStream, EventEmitter);
inherits(uimsdk.Connection, EventEmitter);
inherits(uimsdk.Client, EventEmitter);

/*******************************************************************************
* @class uimsdk.Connection
*******************************************************************************/

/**
 * @method _internalCallback
 * @private
 * 
 * 
 **/
uimsdk.Connection.prototype._internalCallback = function(type, __arg, __arg2){
    switch(type){
        case 'command':
            {
                var args = [__arg.name, __arg];
                args = args.concat(__arg.args);
                if (__arg.streamId && this.streams[__arg.streamId]) {
                    uimsdk.NetStream.prototype.emit.apply(this.streams[__arg.streamId], args);
                } else {
                    this.emit.apply(this, args);
                }
            }
            break;
        case 'cmdSentDone':
            // __arg is cmd
            this.emit('cmdSentDone', __arg);
            break;
        case 'data':
            {
                var args = ['data', __arg];
                if (__arg.streamId && this.streams[__arg.streamId]) {
                    uimsdk.NetStream.prototype.emit.apply(this.streams[__arg.streamId], args);
                } else {
                    this.emit.apply(this, args);
                }
            }
            break;
        case 'bufferEvent':
            {
                // __arg is streamId
                var args = [type, __arg2];
                var streamId = __arg;
                if (streamId && this.streams[streamId] && this.streams[streamId].listenerCount(type) > 0) {
                    uimsdk.NetStream.prototype.emit.apply(this.streams[streamId], args);
                } else {
                    this.emit.apply(this, args);
                }
            }
            break;
        case 'bufferOverflow':
            {
                // __arg is streamId
                var args = [type, arguments[2], arguments[3]];
                var streamId = __arg;
                if (streamId && this.streams[streamId] && this.streams[streamId].listenerCount(type) > 0) {
                    uimsdk.NetStream.prototype.emit.apply(this.streams[streamId], args);
                } else {
                    this.emit.apply(this, args);
                }
            }
            break;
        case 'dataSentDone':
            // __arg is cmd
            this.emit('dataSentDone', __arg);
            break;
        case 'recvRawdata':
            // __arg is data buffer array
            this.emit('recvRawdata', __arg);
            break;
        case 'activeCheck':
            // __arg1 is data active check event type
            // __arg2 is time diff if not equal 0
            this.emit('activeCheck', __arg, __arg2);
            break;
        case 'activeCheckTimeout':
            // __arg1 is active check timeout duration
            this.emit('activeCheckTimeout', __arg);
            break;
        case 'close':
            // __arg is streamId
            if (__arg && this.streams[__arg]) {
                this.streams[__arg].closed = true;
                this.streams[__arg].emit('close');
                delete this.streams[__arg];
            } else {
                var args = ['close'];
                for (var i = 2; i < arguments.length; i++) {
                    args.push(arguments[i]);
                };
                this.emit.apply(this, args);
                delete this.streams;
            }
            break;
    }
}

/**
 * 为特定事件添加一个监听处理程序.
 * 当前支持除'_error/_result/onStatus/error/close'等事件之外的 
 * 任何自定义事件.上述事件为内部保留事件，用户不应定义与这些事件同名的
 * 远程调用函数名。与用户自定义事件相对应的事件处理函数的参数列表与远端
 * 调用时传入的参数列表一致。
 *
 * @method on
 * @public
 * @async
 * @param event_name {String} 要订阅的事件名称
 * @param callback {function} 事件处理函数
 * @example
 *     connection.on('error', function(err){
 *         if (err) {
 *             console.dir(err);
 *         }
 *     });
 **/

/**
 * 连接关闭事件及其事件监听处理程序.
 *
 * @event close
 * @param result {Object} 连接关闭信息。信息含有三个属性:
 *                        result.code是底层错误码，
 *                        result.message是底层错误码对应的解释，
 *                        result.userCode是用户自定义错误代码，
 *                        如果code不为0，说明关闭事件是由底层
 *                        错误引起，此时userCode为0；如果关闭
 *                        动作是由上层js业务逻辑主动出发，此时
 *                        设置的userCode才会被带出.
 * @example
 *     connection.on('close', function(result){
 *         console.log(result); // { message: 'success', code: 0, line: 639, userCode: 100 }
 *     });
 **/

/**
 * 错误事件及其事件监听处理程序.
 * 如果添加'error'事件监听函数，则当出现内部错误时回调函数将被调用。
 *
 * @event error
 * @param error_msg {Error} 错误信息
 * @example
 *     connection.on('error', function(err){
 *         if (err) {
 *             console.dir(err);
 *         }
 *     });
 **/

/**
 * RTMP网络状态事件及其事件监听处理程序.
 * 如果添加'onStatus'事件监听函数，则当出现网络状态事件时回调函数将
 * 被调用。'onStatus'事件发送自网络对端，是一种不需要回复的远程调用，
 * 用于通知网络对端特定的状态信息，包括连接状态等。
 *
 * @event onStatus
 * @param event {Object} 状态信息
 * @example
 *     connection.on('onStatus', function(event){
 *         console.dir(event);
 *     });
 **/

/**
 * 关闭底层RTMP连接.该接口在关闭连接之前会向远端发送关闭连接通知
 * （onStatus:NetConnection.Connect.Closed）。
 * 
 * @method close
 * @public
 * @param userCode {Number} 用户自定义连接关闭码，将在close事件回调中被带出。
 * @example
 *     connection.close(userCode);
 **/
uimsdk.Connection.prototype.close = function(userCode){
    this.__close__(userCode);
}

/**
 * 异步获取数据包及字节数发送统计.
 * 调用该接口将异步获取底层网络数据收发统计。
 *
 * @method stat
 * @public
 * @param callback {function} 异步结果回调函数
 * @example
 *     connection.stat(function(err, stats){
 *         if (err) {
 *             return console.dir(err);
 *         }
 *         console.dir(stats);
 *     })
 **/
uimsdk.Connection.prototype.stat = function(callback){
    this.__stat__(callback);
}

/**
 * 异步设置连接行为参数。
 *
 * @method config
 * @public
 * @param callback {function} 异步结果回调函数
 * @example
 *     connection.config({
 *         activeCheckTimeout : 2000000 // microseconds
 *     }, function(err){
 *         if (err) {
 *             return console.dir(err);
 *         }
 *     });
 **/
uimsdk.Connection.prototype.config = function(config, callback){
    this.__config__(config, callback);
}

 /**
 * 设置开启/关闭命令发送完成通知(该接口主要用于开发调试，建议生产环境
 * 中关闭命令发送完成通知功能以提高运行效率).
 * 如果设置命令发送完成通知功能，则每一个RTMP RPC命令在成功发送完成
 * 后，都可以通过监听'cmdSentDone'事件来捕获发出去的命令包的拷贝。
 * 异步设置完成回调函数的第一个参数为出错信息，如果出错信息为null，
 * 则表明设置成功，否则，表明设置失败。
 *
 * @method openNotify
 * @public
 * @param eNotifyType {enum of mask} 是否开启相应的事件通知,可以是下列
 *        值之一,或是其中几项的组合(通过|组合):
 *        <br>&nbsp;&nbsp;&nbsp;&nbsp;uimsdk.NOTIFY_AUDIO_SENTDONE,
 *        <br>&nbsp;&nbsp;&nbsp;&nbsp;uimsdk.NOTIFY_VIDEO_SENTDONE,
 *        <br>&nbsp;&nbsp;&nbsp;&nbsp;uimsdk.NOTIFY_META_SENTDONE,
 *        <br>&nbsp;&nbsp;&nbsp;&nbsp;uimsdk.NOTIFY_CMD_SENTDONE,
 *        <br>&nbsp;&nbsp;&nbsp;&nbsp;uimsdk.NOTIFY_ALL_SENTDONE,
 *        <br>&nbsp;&nbsp;&nbsp;&nbsp;uimsdk.NOTIFY_ACTIVECHECK
 * @param callback {function} 异步设置完成回调函数
 * @example
 *     connection.openNotify(uimsdk.NOTIFY_CMD_SENTDONE|uimsdk.NOTIFY_ACTIVECHECK,
 *         function(err){
 *             if (err) {
 *                 console.dir(err);
 *             }
 *     });
 **/
uimsdk.Connection.prototype.openNotify = function(mask, callback) {
    if (typeof mask != 'number' || typeof callback != 'function') {
        throw TypeError('Invalid arguments');
    }
    this.__openNotify__(mask, callback);
}

/**
 * 向远端RTMP服务器发起一个连接建立操作。
 * 该接口是一个复合接口，正常情况下将完成三部操作：
 *     <br>&nbsp;&nbsp;&nbsp;&nbsp;1.向远端服务器发起一个TCP连接；
 *     <br>&nbsp;&nbsp;&nbsp;&nbsp;2.TCP连接建立后，将和RTMP服务器完成RTMP握手操作；
 *     <br>&nbsp;&nbsp;&nbsp;&nbsp;3.握手成功后，将发送connect命令到相应的服务端应用（server-side 
 * application）。
 * <br>调用该接口必须指定'onStatus'事件回调函数以捕获连接事件，回调函数形如：
 * <br>&nbsp;&nbsp;&nbsp;&nbsp;function(cmd, event[, arg1, ..., argN]){}
 * <br>判断event.code值是否为下述状态之一，以获得连接结果：
 * <br>&nbsp;&nbsp;&nbsp;&nbsp;1."NetConnection.Connect.AppShutdown"：服务端应用已关闭.
 * <br>&nbsp;&nbsp;&nbsp;&nbsp;2."NetConnection.Connect.Closed"：连接关闭成功.
 * <br>&nbsp;&nbsp;&nbsp;&nbsp;3."NetConnection.Connect.Failed"：连接尝试失败.
 * <br>&nbsp;&nbsp;&nbsp;&nbsp;4."NetConnection.Connect.IdleTimeout"：连接空闲超时.
 * <br>&nbsp;&nbsp;&nbsp;&nbsp;5."NetConnection.Connect.InvalidApp"：服务端应用名不可用.
 * <br>&nbsp;&nbsp;&nbsp;&nbsp;6."NetConnection.Connect.Rejected"：服务端应用拒绝访问.
 * <br>&nbsp;&nbsp;&nbsp;&nbsp;7."NetConnection.Connect.Success"：连接成功.
 * <br>&nbsp;&nbsp;&nbsp;&nbsp;8."NetConnection.Connect.TokenExpired"：token过期.
 *
 * @method connect
 * @public
 * @async
 * @param url {String} 要连接的RTMP服务器的地址，地址形式：
 *                  rtmp://ip:port/app_name
 * @param properties {Object} [可选],命令属性扩展
 * @param ... {Number/String/Boolean/Array/Object/Buffer} [可选],扩展参数项
 * @param cb {function} 异步调用完成回调函数
 * @example
 *     conn.connect('rtmp://127.0.0.1:1935/vod', {key:'value'}, 'abc', function(cmd, event){
 *         console.dir(event);
 *         switch(event.code){
 *         case 'NetConnection.Connect.Success':
 *             // Do continue work
 *             break;
 *         case 'NetConnection.Connect.Failed':
 *             conn.close();
 *             break;
 *         }
 *     });
 **/
uimsdk.Connection.prototype.connect = function(url, properties, cb){
    if (arguments.length < 2 ||
        typeof url != 'string' || 
        typeof arguments[arguments.length - 1] != 'function') {
        throw Error('Invalid arguments');
    };
    var args = [];
    if (arguments.length == 2) {
        properties = null;
    } else if (arguments.length >= 3) {
        for (var i = 2; i < arguments.length - 1; i++) {
            args.push(arguments[i]);
        };
    };
    var callback = arguments[arguments.length - 1];
    parseHost(url, function(err, result){
        if (err) {
            return callback(null, {
                    level : 'error',
                    code : 'NetConnection.Connect.Failed',
                    info : 'invalid url.'
                });
        };
        // url = result.protocol + "://" + result.ip + ":" + result.port + result.location;
        this.__connect__(url, properties, args, function(callback, cmd, err){
            if (err) {
                var evt = {};
                switch(err.message){
                case 'ECONNECT':
                    evt.level = 'error';
                    evt.code = 'NetConnection.Connect.Failed';
                    break;
                case 'ECLOSED':
                    evt.level = 'status';
                    evt.code = 'NetConnection.Connect.Closed';
                    break;
                }
                return callback.call(this, null, evt);
            }
            if (cmd && cmd.args.length > 0 && typeof cmd.args[0] == 'object') {
                var evt = cmd.args[0];
                this.connectedTime = new Date();
                if (evt.clientid) {
                    this.clientId = evt.clientid;
                };
                if (evt.level == 'status' || evt.level == 'error') {
                    var args = [cmd];
                    args = args.concat(cmd.args);
                    callback.apply(this, args);
                } else {
                    callback.call(this, cmd, {
                        level : 'error',
                        code : 'NetConnection.Connect.Failed'
                    });
                }
            } else {
                callback.call(this, cmd, {
                    level : 'error',
                    code : 'NetConnection.Connect.Failed'
                });
            }
        }.bind(this, callback));
    }.bind(this));
}


/**
 * 发送创建一个新流的命令.
 * 该接口是一个复合接口，调用此接口，正常情况下会完成如下操作：
 * <br>&nbsp;&nbsp;&nbsp;&nbsp;1.向远端服务器发送一个'createStream'
 * 远程调用；
 * <br>&nbsp;&nbsp;&nbsp;&nbsp;2.如果调用成功，将得到服务端返回的
 * streamId，然后在内部会创建一个NetStream类型的对象，将服务端返
 * 回的streamId赋予该NetStream实例；
 * <br>&nbsp;&nbsp;&nbsp;&nbsp;3.将接口调用错误信息和NetStream实
 * 例通过回调函数返回。
 * <br>如果接口调用出错，err将不为null，stream不可用；反之，err
 * 为null,stream对象可用。
 *
 * @method createStream
 * @public
 * @example
 *     conn.createStream(function(err, stream){
 *         console.dir(arguments);
 *         if (err) {
 *             return console.log(err);
 *         }
 *         // Do continue work
 *     });
 **/
uimsdk.Connection.prototype.createStream = function(callback){
    var self = this;
    if (typeof callback != 'function') {
        throw Error('Invalid arguments');
    };
    self.call('createStream', null, function(cmd, streamId){
        if (typeof streamId != 'number') {
            callback(new Error('Failed to call createStream.'));
        };
        self.__createStream__(streamId, function(errCode){
            // console.log('errCode :', errCode);
            if (errCode) {
                return callback(new Error('Failed to create stream.'));
            };
            var stream = new uimsdk.NetStream(self, streamId);
            callback(null, stream);
        });
    });
}

/**
 * 调用一个远端处理函数.
 * 如果指定返回结果的回调处理函数，则远端理论上应该返回结果，该结果由
 * 该回调函数处理，否则，不返回结果。回调函数的第一个参数为远端返回的
 * 调用对象（uimsdk.RTMPCall实例）。理论上，返回结果也是一个远程调用，只
 * 不过是针对特定函数_result和_error函数的特定调用。返回_result表示远
 * 端函数正确执行；返回_error则表示远端函数执行出错。
 *
 * @method call
 * @public
 * @async
 * @param proc_name {String} 要调用的远端函数的名称
 * @param ... {Number/String/Boolean/Array/Object/Buffer} [可选], 要
 *                          传递给远端函数的参数
 * @param callback {function} [可选], 远端函数返回结果的处理函数
 * @example
 *     connection.call('foo', 'arg1', 'arg2', function(cmd){
 *         console.dir(cmd);
 *     });
 **/
uimsdk.Connection.prototype.call = function(){
    var args = [];
    for (var i = 0; i < arguments.length; i++) {
        if (i + 1 < arguments.length && typeof arguments[i] == 'function') {
            throw Error('Invalid arguments');
        };
        args.push(arguments[i]);
    };
    var name = args[0] || null;
    if (!name) {
        throw Error('Invalid arguments');
    };
    var cmd = {};
    cmd.name = args.shift();
    if (args.length > 0 && typeof args[args.length - 1] == 'function') {
        cmd.callback = call_cb.bind(this, args.pop());
    }
    if (!args.length) {
        throw Error('Invalid arguments, property object MUST BE assigned.');
    };
    cmd.props = args.shift();
    cmd.args = args;
    cmd.channelId = 3;
    cmd.streamId = 0;
    if (cmd.name === 'onStatus') {
        this.__call__(cmd, 0);
    } else{
        this.__call__(cmd);
    };
}

/**
 * 关闭一个指定的流.
 *
 * @method closeStream
 * @public
 * @async
 * @param stream_id {Number} 要关闭的流的id
 * @param callback {function}, 返回结果的处理函数
 * @example
 *     client.closeStream(streamId, function(err){
 *         if (err) {
 *             return console.dir(err);
 *         } else {
 *             // do some thing
 *         }
 *     });
 **/
uimsdk.Connection.prototype.closeStream = function(streamId, callback) {
    var self = this;
    var stream = self.streams[streamId];
    if (typeof callback != 'function' || !stream instanceof uimsdk.NetStream) {
        throw TypeError('Invalid arguments');
    }
    if (!stream.closed) {
        stream.call('closeStream', null);
        self.__closeStream__(streamId, function(err){
            stream.closed = true;
            callback.call(self, err);
        });
    }
}

/**
 * Connection之上的所有NetStream实例数组.
 * 通过streamId为索引访问相应的NetStream实例。
 *
 * @property streams
 * @type Array of NetStream
 * @public
 * @example
 *     var streams = conn.streams;
 *     for (var i = 0;i < streams.length;i++) {
 *         console.dir(streams[i]);
 *     }
 **/

/**
 * 唯一标识一个连接的标志.
 * Connection实例具有不重复的ID。
 *
 * @property clientId
 * @type String
 * @public
 *
 *     console.log(connection.clientId);
 **/

/*******************************************************************************
* @class uimsdk.Client
*******************************************************************************/

/**
 * @method _internalCallback
 * @private
 * 
 * 
 **/
uimsdk.Client.prototype._internalCallback = function(type, __arg2, __arg3){
    switch(type){
        case 'command':
            {
                var args = [__arg2.name, __arg2];
                args = args.concat(__arg2.args);
                this.emit.apply(this, args);
            }
            break;
        case 'message':
            this.emit(type, __arg2);
            break;
        case 'close':
            this.emit('close');
            break;
        case 'login': // client logged in
            // __arg2 is result.
            if (__arg2 && __arg2.code === 'Client.Login.Success'){
                this.connected = true;
            }
            this.emit('login', __arg2);
            break;
        case 'logout':
            this.connected = false;
            this.emit('logout');
            break;
        case 'session': // client read sessions
            // __arg2 is sessions.
            this.emit('session', __arg2);
            break;
        case 'offline':
            this.connected = false;
            this.emit('offline');
            break;
        case 'send': // client logged in
            // __arg2 is result.
            this.emit('send', __arg2);
            break;
    }
}

/**
 * 为特定事件添加一个监听处理程序.
 * 当前支持除'_error/_result/onStatus/error/close'等事件之外的 
 * 任何自定义事件.上述事件为内部保留事件，用户不应定义与这些事件同名的
 * 远程调用函数名。与用户自定义事件相对应的事件处理函数的参数列表与远端
 * 调用时传入的参数列表一致。
 *
 * @method on
 * @public
 * @async
 * @param event_name {String} 要订阅的事件名称
 * @param callback {function} 事件处理函数
 * @example
 *     client.on('error', function(err){
 *         if (err) {
 *             console.dir(err);
 *         }
 *     });
 **/

/**
 * 登入结果通知
 *
 * @event login
 * @param event {Object} 状态信息
 * @example
 *     client.on('login', function(info){
 *         console.dir(info);
 *     });
 **/

/**
 * 登出结果通知
 *
 * @event logout
 * @param event {Object} 状态信息
 * @example
 *     client.on('logout', function(info){
 *         console.dir(info);
 *     });
 **/

/**
 * 预览关闭事件及其事件监听处理程序.
 *
 * @event close
 * @example
 *     client.on('close', function(){
 *         // do something
 *     });
 **/

/**
 * 错误事件及其事件监听处理程序.
 * 如果添加'error'事件监听函数，则当出现内部错误时回调函数将被调用。
 *
 * @event error
 * @param error_msg {Error} 错误信息
 * @example
 *     client.on('error', function(err){
 *         if (err) {
 *             console.dir(err);
 *         }
 *     });
 **/

/**
 * 视频图像数据
 *
 * @event data
 * @param width {Number} 画面宽度
 * @param height {Number} 画面高度
 * @example
 *     client.on('data', function(width, height){
 *         console.dir(width, height);
 *     });
 **/

/**
 * 用户登入接口。
 *
 * @method login
 * @public
 * @sync
 * @param info {Object} user info. 
 * @example
 *     client.login(info);
 **/
uimsdk.Client.prototype.login = function(info){
    if (!info) {
        throw Error('Invalid arguments, object required.');
    };
    return this.__login__(info);
}

/**
 * 创建会话。
 *
 * @method createSession
 * @public
 * @sync
 * @param userIds {Array} list of userIds. 
 * @example
 *     client.createSession(userIds);
 **/
uimsdk.Client.prototype.createSession = function(userIds){
    if (!userIds) {
        throw Error('Invalid arguments, array required.');
    };
    return this.__createSession__(userIds);
}

/**
 * 获取chat数据。
 *
 * @method getChat
 * @public
 * @sync
 * @param chatIds {Array} list of chat ids. 
 * @example
 *     var chats = client.getChat(chatIds);
 **/
uimsdk.Client.prototype.getChat = function(chatIds){
    if (!chatIds || !(chatIds instanceof Array)) {
        throw Error('Invalid arguments, array required.');
    };
    return this.__getChat__(chatIds);
}

/**
 * 获取user数据。
 *
 * @method getUser
 * @public
 * @sync
 * @param userIds {Array} list of user ids. 
 * @example
 *     var users = client.getUser(userIds);
 **/
uimsdk.Client.prototype.getUser = function(userIds){
    if (!userIds || !(userIds instanceof Array)) {
        throw Error('Invalid arguments, array required.');
    };
    return this.__getUser__(userIds);
}

/**
 * 根据指定的chat_id获取user数据。
 *
 * @method getUserByChat
 * @public
 * @sync
 * @param chatIds {Array} list of chat ids. 
 * @example
 *     var users = client.getUserByChat(chatIds);
 **/
uimsdk.Client.prototype.getUserByChat = function(chatIds){
    if (!chatIds || !(chatIds instanceof Array)) {
        throw Error('Invalid arguments, array required.');
    };
    return this.__getUserByChat__(chatIds);
}

/**
 * 根据指定的chat_id获取session数据。
 *
 * @method getSessionByChat
 * @public
 * @sync
 * @param chatId {Number} chat id. 
 * @example
 *     var sessionInfo = client.getSessionByChat(chatId);
 **/
uimsdk.Client.prototype.getSessionByChat = function(chatId){
    if (!chatId) {
        throw Error('Invalid arguments, chatId required.');
    };
    return this.__getSessionByChat__(chatId);
}

/**
 * 发送消息。
 *
 * @method sendMessage
 * @public
 * @sync
 * @param chatId {Number} chat Id, alias room id. 
 * @param message {Object} message object contains 'message' property. 
 * @example
 *     client.sendMessage(chatId, message);
 **/
uimsdk.Client.prototype.sendMessage = function(chatId, message){
    if (!chatId || typeof message != 'object' || (!message.message && message.type == 0)) {
        throw Error('Invalid arguments, chatId and object ' 
            + 'with \'message\' attribute required.');
    };
    return this.__sendMessage__(chatId, message);
}

/**
 * 根据指定的id获取message数据。
 *
 * @method getMessageById
 * @public
 * @sync
 * @param msgIds {Array}  array of message id. 
 * @example
 *     var sessionInfo = client.getMessageById(msgIds);
 **/
uimsdk.Client.prototype.getMessageById = function(msgIds){
    if (!msgIds || !(msgIds instanceof Array)) {
        throw Error('Invalid arguments, array of ids required.');
    };
    return this.__getMessageById__(msgIds);
}

/**
 * 获取指定范围的未读message数据。
 *
 * @method getUnreadMessage
 * @public
 * @sync
 * @param startIndex {Number} start index of unread message. 
 * @param pageSize {Number} page size of unread message to return. 
 * @return message {Array} array of unread messages
 * @example
 *     var sessionInfo = client.getUnreadMessage(startIndex, pageSize);
 **/
uimsdk.Client.prototype.getUnreadMessage = function(startIndex, pageSize){
    if (typeof startIndex !== 'number' || typeof pageSize !== 'number') {
        throw Error('Invalid arguments, array of ids required.');
    };
    return this.__getUnreadMessage__(startIndex, pageSize);
}

/**
 * 将指定id的message设为已读。
 *
 * @method setMessageRead
 * @public
 * @sync
 * @param msgIds {Array}  array of message id. 
 * @example
 *     var sessionInfo = client.setMessageRead(msgIds);
 **/
uimsdk.Client.prototype.setMessageRead = function(msgIds){
    if (!msgIds || !(msgIds instanceof Array)) {
        throw Error('Invalid arguments, array of ids required.');
    };
    return this.__setMessageRead__(msgIds);
}

/**
 * 用户登出接口。
 *
 * @method logout
 * @public
 * @sync
 * @example
 *     client.logout();
 **/
uimsdk.Client.prototype.logout = function(){
    return this.__logout__();
}

/**
 * 关闭播放器。
 *
 * @method close
 * @public
 * @sync
 * @example
 *     client.close();
 **/
uimsdk.Client.prototype.close = function(){
    return this.__close__();
}

/*******************************************************************************
* @class 
*******************************************************************************/

/**
 * 指定日志路径.
 *
 * @method openLog
 * @public
 * @param logPath {String} 日志文件路径.
 * @example
 *     uimsdk.openLog('d:/work/bin/log/uimsdk.log');
 **/
uimsdk.openLog = function(logPath){
    return uimsdk.__openLog__(logPath);
}

/**
 * 创建连接实例.
 *
 * @method createConnection
 * @public
 * @param config {Object} connection config. 
 * @example
 *     var conn = uimsdk.createConnection(config);
 **/
uimsdk.createConnection = function(config){
    return uimsdk.__createConnection__(config);
}

/**
 * 创建IM客户端实例.
 *
 * @method createClient
 * @public
 * @param config {Object} user client config. 
 * @example
 *     var client = uimsdk.createClient(config);
 **/
uimsdk.createClient = function(config){
    return uimsdk.__createClient__(config);
}

//*******************************************************************************
// Exports : 
//*******************************************************************************

module.exports = uimsdk;

//*******************************************************************************
// End of file : uimsdk.js
//*******************************************************************************
